package main

import (
	"fmt"
	"os/exec"
)

func main() {
	cmd := exec.Command("cmd", "/C", "dir")

	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Println("error:", err)
		return
	}

	fmt.Println("output:", string(output))
}
	
/*

===== USING PIPE =====

func main() {
	pr, pw := io.Pipe()
	cmd := exec.Command("findstr", "foo")
	cmd.Stdin = pr

	go func() {
		defer pw.Close()
		pw.Write([]byte("food is good\nbar\nbaz\n"))
	}()

	output, err := cmd.Output()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("Output:", string(output))

}

func main() {
	cmd := exec.Command("cmd", "/C", "echo", "%SHELL%")

	output, err := cmd.Output()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("output:", string(output))

}

func main() {

	cmd := exec.Command("ping", "127.0.0.1", "-n", "60")

	// start the command here
	err := cmd.Start()
	if err != nil {
		fmt.Println("error starting cmd:", err)
		return
	}

	time.Sleep(2 * time.Second)

	err = cmd.Process.Kill()
	if err != nil {
		fmt.Println("Error starting command:", err)
		return
	}
	fmt.Println("process killed")

	// waiting
	// err = cmd.Wait()
	// if err != nil {
	// 	fmt.Println("error waiting:", err)
	// 	return
	// }

	//fmt.Println("process complete")
	cmd := exec.Command("findstr", "foo")

	// Set input for command
	cmd.Stdin = strings.NewReader("food is good\nbar\nbaz\n")
	output, err := cmd.Output()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("output:", string(output))

		cmd := exec.Command("cmd", "/C", "echo", "Hello World!")
		output, err := cmd.Output()
		if err != nil {
			fmt.Println("error:", err)
			return
		}

		fmt.Println("Output:", string(output))

	}
*/
